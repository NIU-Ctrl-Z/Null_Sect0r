Наконец-то в книжках начали прикладывать его великие онлайн-задачи! Только, как обычно, в конце книжки нет решений...


*По заданию дан файл «encrypted.png».*
___
Дан сломанный png файл, который не открывается в стандартных просмотрщиках из-за повреждения сигнатурных байтов PNG. Открыли файл в HxD, увидели, что первые байты не совпадают с сигнатурой PNG, а простая их замена не дала результата.

Дальше решили попробовать вычислить XOR первых байтов файла и стандартной сигнатуры PNG, чтобы проверить, не скрыто ли что-то.

![[Pasted image 20251117192615.png]]

В результате получили hex-строку `332e313431353932`, что декодируется как ASCII-строка `3.141592`  (мы использовали DenCode для этого).

![[Pasted image 20251117193620.png]]

Это число π — появилась идея проксорить каждый байт исходного файла поочередно с цифрами числа π.

```python
 # Открываем зашифрованный файл
with open('encrypted.png', 'rb') as f:
    encrypted_data = f.read()

# Определяем ключ как байты
key = b'тут число пи. Оно очень большое, поэтому я просто текст сюда написал'

# Расшифровываем данные с помощью XOR
decrypted_data = bytearray()
for i in range(len(encrypted_data)):
    decrypted_byte = encrypted_data[i] ^ key[i % len(key)]
    decrypted_data.append(decrypted_byte)

# Сохраняем расшифрованный файл
with open('decrypted.png', 'wb') as f:
    f.write(decrypted_data)

print("Файл успешно расшифрован! Откройте decrypted.png.")
```

После выполнения XOR всего файла с этим числом получили открывающийся PNG, но флаг был виден не полностью.

![[decrypted_half.png]]

Догадались, что дело в урезанной высоте изображения. Открыли обрезанное изображение в HxD и заменили байты высоты с `00 00 01 90` (400 пикселей) на `00 00 03 20` (800 пикселей).

![[Pasted image 20251118105830.png]]

![[image_2025-11-14_14-50-44.png]]

В итоге мы получаем полное изображение с флагом.

![[Pasted image 20251118110048.png]]

## `ctfschool{p1_m4th3m4t1cs_n33d_t0_b3_l3arn3d}`
Они знают... Знают, что я боюсь смотреть на них... Делать операции с ними... Но всё равно появляются в моей жизни...

Помогите, я долго не протяну...

*По заданию дан файл «big_numbers.txt».*
___

Решение задачи начинается с того, что у нас есть два очень больших числа:
  
```
num1 = 5857548458341923611131951534368123497456531178093681337111212078932230466163561572442865254222900553266045

num2 = 2293498615990071511610820895302086940796564989168281123737588839386922876088484808070018553110125686554624

```
  
Поскольку задание относится к криптографии и упоминает операции над числами, логично предположить, что используется шифр Вернама, основанный на операции XOR. 

Чтобы выполнить XOR, нужно представить каждое число в виде последовательности байтов — то есть преобразовать их из числового формата в байтовый. Каждое число преобразуется в последовательность байтов в формате big-endian — старший байт впереди — с помощью метода to_bytes, где для выделения нужного количества байт используется битовая длина числа.

```python
# Переводим в байты (big-endian)
b1 = n1.to_bytes((n1.bit_length() + 7) // 8, 'big')
b2 = n2.to_bytes((n2.bit_length() + 7) // 8, 'big')
```

Далее производится побайтовый XOR — для каждого байта из первого числа применяется операция исключающего ИЛИ с соответствующим байтом второго числа. Результат этой операции получается в виде байтовой строки, которую мы пытаемся расшифровать в ASCII.

```python
# XOR
xored = bytes(a ^ b for a, b in zip(b1, b2))

ascii_result = xored.decode('ascii', errors='ignore')

print(ascii_result)
```

Вывод:
```
tfschool{b4s3s_4r3_v3ry_c00l_1n_d1ff3r3nc3}
```

Нам известно, что флаги CTF School Finals начинаются с `ctfschool{`, поэтому добавляем пропущенную `c` в начале и в итоге получается читаемый текст, который является флагом.

## `ctfschool{b4s3s_4r3_v3ry_c00l_1n_d1ff3r3nc3}`
Странные ноты скинул знакомый мне гитарист, сказал, что это музыка полностью отражает его душу.

```
D 00 D# G# D A D F D F# D F D# 00 D# 22 D F D# G# D E D# A D# 22 F# G D F# C# D D# F# F# G D G C# 22 D C# G 22 D D# D# D C# 00 D E D# 11 D# F G A D# C# D E G G# D# 11 F# G G F D D# C 00 D G G A G D# D# E
```
____

Разбиваем строку по пробелам. Строка состоит из 82 токенов (нот), всего 13 различных символов (нот и спецзнаков).

- Ноты: `C, C#, D, D#, E, F, F#, G, G#, A`
- Спец-символы: `00, 11, 22`

Строка состоит из чётного количества токенов. Приходим к мысли, что каждая нота\символ кодирует 4 бита информации, а две ноты\символы подряд — один байт (8 бит). Нужно понять, какие числа соответствуют нотам\символам.

Самое логичное - взять ноты в обычном музыкальном порядке:
```
C, C#, D, D#, E, F, F#, G, G#, A
```
А спец-значения `00, 11, 22` прилепить в конец. Тогда каждые нота и символ — число от 0 до 12 (0xC).

Преобразуем это в словарь, где `C → 0; C# → 1; D → 2; D# → 3; E → 4; F → 5; F# → 6; G → 7; G# → 8; A → 9; 00 → 10 (0xA); 11 → 11 (0xB); 22 → 12 (0xC)`:

```python
order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', '00', '11', '22']
note_to_nibble = {sym: i for i, sym in enumerate(order)}
```

Разбиваем строку по пробелам, потом для каждой ноты\символа берем число из словаря:
```python
notes_str = "D 00 D# G# D A D F D F# D F D# 00 D# 22 D F D# G# D E D# A D# 22 F# G D F# C# D D# F# F# G D G C# 22 D C# G 22 D D# D# D C# 00 D E D# 11 D# F G A D# C# D E G G# D# 11 F# G G F D D# C 00 D G G A G D# D# E"

notes = notes_str.split()
nibbles = [note_to_nibble[n] for n in notes]
```

Из чисел формируем байты. Каждый байт — это два числа:  
$byte=hi×16+lo$, где $hi$ — старший полубайт, а $lo$ — младший.

```python
cipher = bytes(
    (nibbles[i] * 16 + nibbles[i+1])
    for i in range(0, len(nibbles), 2)
)

print(cipher)
```
Вывод:
```
b"*8)%&%:<%8$9<g&\x126g'\x1c!|#2\x1a$;5y1$x;gu#\n'ys4" 
```
Теперь `cipher` — это байтовая строка шифротекста (префикс b перед кавычками означает, что это байтовая строка (тип `bytes`, а не `str`)).

Нам известно, что флаги CTF School Finals начинаются с `ctfschool{`. Поскольку часть открытого текста (начало флага, далее в коде "префикс") нам известна — `ctfschool{`, мы можем сравнить первые символы зашифрованного текста с соответствующими символами `ctfschool{`. Из этого сравнения, применяя XOR, выведем ключ.

*Такой прием называется "известный открытый текст" (known-plaintext attack) и часто используется в криптографии для взлома простых XOR-шифров.*

$key = cipher ⊕ plaintext$

Считаем ключ:
```python
pt_prefix = b"ctfschool{"

key = bytes(
    c ^ p
    for c, p in zip(cipher[:len(pt_prefix)], pt_prefix)
)
```
Вывод:
```
b'ILOVEMUSIC'
```
Мы получили ключ с длиной 10 байт `ILOVEMUSIC`

Это потоковый XOR с повторяющимся ключом, поэтому идем по всему шифротексту и XOR-им по кругу с ключом, после чего декодируем байты в строку:
```python
full_pt = bytes(
    cipher[i] ^ key[i % len(key)]
    for i in range(len(cipher))
)

print(full_pt.decode('utf-8'))
```
Вывод:
```
ctfschool{mus1c_c4n_h0ld_inf0rm4t10n_t00}
```
Так мы и получаем флаг.
## `ctfschool{mus1c_c4n_h0ld_inf0rm4t10n_t00}`